"""
ME RIGHT NOW 👇

´´´´´´´´´´´´´´´´´´´ ¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´´´´´´´´´´´´´´´´`
´´´´´´´´´´´´´´´´´¶¶¶¶¶¶´´´´´´´´´´´´´¶¶¶¶¶¶¶´´´´´´´´´´´´´´´´
´´´´´´´´´´´´´´¶¶¶¶´´´´´´´´´´´´´´´´´´´´´´´¶¶¶¶´´´´´´´´´´´´´´
´´´´´´´´´´´´´¶¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶´´´´´´´´´´´´
´´´´´´´´´´´´¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶´´´´´´´´´´´
´´´´´´´´´´´¶¶´´´´´´´´´´´´´´´´´´´´´`´´´´´´´´´´´¶¶´´´´´´´´´´`
´´´´´´´´´´¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶´´´´´´´´´´
´´´´´´´´´´¶¶´¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶´¶¶´´´´´´´´´´
´´´´´´´´´´¶¶´¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶´´¶´´´´´´´´´´
´´´´´´´´´´¶¶´¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶´´¶´´´´´´´´´´
´´´´´´´´´´¶¶´´¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶´¶¶´´´´´´´´´´
´´´´´´´´´´¶¶´´¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶´´¶¶´´´´´´´´´´
´´´´´´´´´´´¶¶´¶¶´´´¶¶¶¶¶¶¶¶´´´´´¶¶¶¶¶¶¶¶´´´¶¶´¶¶´´´´´´´´´´´
´´´´´´´´´´´´¶¶¶¶´¶¶¶¶¶¶¶¶¶¶´´´´´¶¶¶¶¶¶¶¶¶¶´¶¶¶¶¶´´´´´´´´´´´
´´´´´´´´´´´´´¶¶¶´¶¶¶¶¶¶¶¶¶¶´´´´´¶¶¶¶¶¶¶¶¶¶´¶¶¶´´´´´´´´´´´´´
´´´´¶¶¶´´´´´´´¶¶´´¶¶¶¶¶¶¶¶´´´´´´´¶¶¶¶¶¶¶¶¶´´¶¶´´´´´´¶¶¶¶´´´
´´´¶¶¶¶¶´´´´´¶¶´´´¶¶¶¶¶¶¶´´´¶¶¶´´´¶¶¶¶¶¶¶´´´¶¶´´´´´¶¶¶¶¶¶´´
´´¶¶´´´¶¶´´´´¶¶´´´´´¶¶¶´´´´¶¶¶¶¶´´´´¶¶¶´´´´´¶¶´´´´¶¶´´´¶¶´´
´¶¶¶´´´´¶¶¶¶´´¶¶´´´´´´´´´´¶¶¶¶¶¶¶´´´´´´´´´´¶¶´´¶¶¶¶´´´´¶¶¶´
¶¶´´´´´´´´´¶¶¶¶¶¶¶¶´´´´´´´¶¶¶¶¶¶¶´´´´´´´¶¶¶¶¶¶¶¶¶´´´´´´´´¶¶
¶¶¶¶¶¶¶¶¶´´´´´¶¶¶¶¶¶¶¶´´´´¶¶¶¶¶¶¶´´´´¶¶¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶¶¶
´´¶¶¶¶´¶¶¶¶¶´´´´´´¶¶¶¶¶´´´´´´´´´´´´´´¶¶¶´¶¶´´´´´¶¶¶¶¶¶´¶¶¶´
´´´´´´´´´´¶¶¶¶¶¶´´¶¶¶´´¶¶´´´´´´´´´´´¶¶´´¶¶¶´´¶¶¶¶¶¶´´´´´´´´
´´´´´´´´´´´´´´¶¶¶¶¶¶´¶¶´¶¶¶¶¶¶¶¶¶¶¶´¶¶´¶¶¶¶¶¶´´´´´´´´´´´´´´
´´´´´´´´´´´´´´´´´´¶¶´¶¶´¶´¶´¶´¶´¶´¶´¶´¶´¶¶´´´´´´´´´´´´´´´´´
´´´´´´´´´´´´´´´´¶¶¶¶´´¶´¶´¶´¶´¶´¶´¶´¶´´´¶¶¶¶¶´´´´´´´´´´´´´´
´´´´´´´´´´´´¶¶¶¶¶´¶¶´´´¶¶¶¶¶¶¶¶¶¶¶¶¶´´´¶¶´¶¶¶¶¶´´´´´´´´´´´´
´´´´¶¶¶¶¶¶¶¶¶¶´´´´´¶¶´´´´´´´´´´´´´´´´´¶¶´´´´´´¶¶¶¶¶¶¶¶¶´´´´
´´´¶¶´´´´´´´´´´´¶¶¶¶¶¶¶´´´´´´´´´´´´´¶¶¶¶¶¶¶¶´´´´´´´´´´¶¶´´´
´´´´¶¶¶´´´´´¶¶¶¶¶´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´´¶¶¶¶¶´´´´´¶¶¶´´´´
´´´´´´¶¶´´´¶¶¶´´´´´´´´´´´¶¶¶¶¶¶¶¶¶´´´´´´´´´´´¶¶¶´´´¶¶´´´´´´
´´´´´´¶¶´´¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶´´¶¶´´´´´´
´´´´´´´¶¶¶¶´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´´¶¶¶¶´´´´´´´
"""

import json
import random
import time
from datetime import datetime
import requests
from aiogram import types
from aiogram.utils.exceptions import BotBlocked, MessageError
from aiogram.utils.markdown import bold, text
from bson import ObjectId

from common import (
    delete_keyboard,
    get_options,
    today_is_the_day,
    utc_date_is_the_day,
    get_pictures,
    rand_select_obj_texts,
    Weekdays,
    n_days_since_date,
    any_ratings_in_previous_n_days
)
from keyboards import (
    kb_for_mental_poll,
    support_start_keyboard,
    ask_for_rate_messages
)
from volunteers import is_mental_rate_threashhold_reached, how_many_days_user_with_us
from variables import (
    CONTENTFUL_API_READONLY_URL,
    CONTENTFUL_SPACE_ID,
    CONTENTFUL_ACCESS_TOKEN,
    LINK_TO_FORM,
    botClient
)
from ratestata import send_rate_stata
from friends import send_a_friend_message_about_bad_mood
from db.users import (
    get_user_by_telegram_id,
    update_user_is_active
)
from db.mental_rate import (
    get_unrated_mental_rate,
    get_mental_rate_by_user_and_tg_message,
    insert_new_mental_rate,
    update_mental_rate_value
)
from db.messages import (
    get_message_to_send_to_user
)
from db.user_messages import (
    insert_new_user_message,
    get_latest_message_by_user
)
from db.rate import (
    get_rate_by_user_and_message
)


# read texts from json file
with open('texts.json', encoding="utf-8") as t:
    texts = json.load(t)


async def sendmes(chat_id: int):
    """
    Message handler for /sendmes command

    Parameters:
    chat_id (int): Telegram ID of user to send message

    Returns:
    None
    """

    try:
        user = get_user_by_telegram_id(str(chat_id))
        prev_unrated_message = get_unrated_mental_rate(user["_id"])

        if prev_unrated_message:
            await delete_keyboard(chat_id, prev_unrated_message['id_tg_message'])

        message_id = await botClient.send_message(
            chat_id,
            get_options('polls_questions'),
            parse_mode=types.ParseMode.MARKDOWN,
            reply_markup=kb_for_mental_poll
        )

        insert_new_mental_rate(
            user['_id'],
            0,
            message_id
        )

    except BotBlocked:
        print(f"Юзер {chat_id} пидор, заблочил бота")
        update_user_is_active(user['_id'], False)

    except MessageError:
        await botClient.send_message(
            chat_id,
            (
                "Ой, кажется, что-то пошло не так 😞 \n"
                "Повтори отправку настроения через несколько минут или "
                "напиши разработчикам через команду /feedback"
            )
        )


async def callback_after_click_on_color_button(
    callback_query: types.CallbackQuery,
    rate: int,
    color: str
):
    """
    Callback handler for /sendmes

    Parameters:
    callback_query (TG Callback): callback to handle, can be
        "green_button_answer"
        "yellow_button_answer"
        "orange_button_answer"
        "red_button_answer"
    rate (int): rate of mental state, from 1 to 4 (red to green)
    color (str): color of mental state, can be:
        "green"
        "yellow"
        "orange"
        "red"

    Returns:
    None
    """

    await botClient.answer_callback_query(callback_query.id)
    await delete_keyboard(callback_query.from_user.id, callback_query.message.message_id)

    try:
        # добавил две строки ниже, чтобы по коллбеку стирать контекст общения с чатжпт,
        #   чтобы он не копился
        # UPD: не добавил( надо написать чето,
        #   чтобы контекст общения с чатжпт не держался в памяти, а дропался по крону в полночь :(
        #   сорри пацаны
        # if array_of_chats != None:
        #    array_of_chats.delete_array(callback_query.from_user.id)
        #    array_of_chats.add_message(
        #        callback_query.from_user.id,
        #        {
        #            'role': 'assistant',
        #            'content': (
        #                "Отвечай от имени Роджера. Это бот, "
        #                "который поддерживает людей с плохим настроением"
        #            )
        #         }
        #     )

        user = get_user_by_telegram_id(str(callback_query.from_user.id))

        # find_one_and_update returns a record that is to be updated;
        #   in this case it is irrelevant whether
        # we receive the updated version of the record or not, since we're only
        # interested in the date
        rate_record = get_mental_rate_by_user_and_tg_message(
            user["_id"],
            callback_query.message.message_id
        )
        update_mental_rate_value(rate_record['_id'], rate)

        await get_options_color(color, callback_query.from_user.id)
        await row_message(callback_query.from_user.id)
        await is_mental_rate_threashhold_reached(callback_query.from_user.id, 'volunteer')

        if rate_record is not None:
            if need_send_weekly_rate_stata(
                    int(user['timezone']), user['created_at'], user['_id'], rate_record['date']):
                await sunday_send_rate_stata(callback_query.from_user.id, rate_record['date'])

        # отключил чатжпт в колбеках
        # await offer_to_chat_with_chatgpt(color, callback_query.from_user.id)
        if color in ('red', 'orange'):
            await send_a_friend_message_about_bad_mood(callback_query.from_user.id, color)

    except MessageError:
        await botClient.send_message(
            callback_query.from_user.id,
            (
                "Ой, кажется, что-то пошло не так 😞 \n"
                "Напиши разработчикам через команду /feedback, "
                "они помогут разобраться с проблемой 👌"
            )
        )


async def create_message_with_support(
    user: dict,
    message_to_send: dict
):
    """
    Function to create message with support images/videos/gifs

    Parameters:
    user (dict): User dict from DB
    message_to_send: (dict): message to send to user, dict from DB

    Returns:
    None
    """

    chat_id = user["telegram_id"]
    message = ""

    if message_to_send['is_anonymous']:
        message = text(bold("Имя: ") + "Аноним" + '\n')
    else:
        message = text(
            bold("Имя: ") +
            message_to_send["user"][0]["name"] +
            '\n')

    if len(message_to_send['image_ids']) > 0:
        message = message + '\n' + text(bold('Вложения:'))

        await botClient.send_message(chat_id, message, parse_mode=types.ParseMode.MARKDOWN)

        message = ""
        media = types.MediaGroup()

        for i in message_to_send['image_ids']:
            picture_url = await get_pictures(i)
            if '.gif' in picture_url:
                # Пробовал attach_video тут, но почему-то крашится
                media.attach_photo(picture_url)
            else:
                media.attach_photo(picture_url + '?fm=jpg')

        await botClient.send_media_group(chat_id, media=media)
    else:
        message = message + '\n'

    # телега не пускает сообщения с этими символами, сделали экранирование
    # вместе 🤝
    message_to_send['text'] = message_to_send['text'].replace("_", "\\_")
    message_to_send['text'] = message_to_send['text'].replace("*", "\\*")
    message_to_send['text'] = message_to_send['text'].replace("`", "\\`")
    message_to_send['text'] = message_to_send['text'].replace("[", "\\[")

    message = message + text(bold("Сообщение: ") +
                             '\n' + message_to_send['text'] + '\n')
    message = message + '\n'
    if message_to_send['media_link'] != "":
        message = message + \
            text(
                bold("Что стоит глянуть: ") +
                '\n' +
                message_to_send['media_link'])
    try:
        prev_message = get_latest_message_by_user(user["_id"])

        if prev_message is not None:
            rate_previous_mes = get_rate_by_user_and_message(
                user["_id"], prev_message['id_message'])

            if rate_previous_mes is None:
                await delete_keyboard(chat_id, prev_message['id_tg_message'])

        id_message = await botClient.send_message(
            chat_id,
            message,
            parse_mode=types.ParseMode.MARKDOWN,
            disable_web_page_preview=True,
            reply_markup=ask_for_rate_messages
        )

        print("\n")
        print('USER_MESSAGES -> ты увидел сообщение')
        print(
            {
                "id_user": user['_id'],
                "id_message": message_to_send["_id"],
                "time_to_send": datetime.now(),
                "id_tg_message": id_message.message_id
            }
        )

        insert_new_user_message(
            user["_id"],
            message_to_send["_id"],
            id_message.message_id
        )
    except MessageError:
        await botClient.send_message(
            chat_id,
            (
                "Ой, кажется, что-то пошло не так 😞 \n"
                "Напиши разработчикам через команду /feedback, "
                "они помогут разобраться с проблемой 👌"
            )
        )


async def get_cat_gif():
    """
    Function to get a random support gif URL

    Parameters:

    Returns:
    str
    """

    response = requests.get(
        CONTENTFUL_API_READONLY_URL + 'spaces/' +
        CONTENTFUL_SPACE_ID + '/environments/master/assets?access_token=' +
        CONTENTFUL_ACCESS_TOKEN + '&metadata.tags.sys.id[all]=catGifs',
        timeout=10
    )
    all_gifs = json.loads(response.content).get("items")

    random_gif = all_gifs[random.randint(0, len(all_gifs) - 1)]
    gif_link = str(random_gif.get("fields").get("file").get("url")[2:])

    print(gif_link)

    return gif_link


async def get_video_when_no_messages():
    """
    Function to get a support random video URL

    Parameters:

    Returns:
    str
    """

    response = requests.get(
        CONTENTFUL_API_READONLY_URL + 'spaces/' +
        CONTENTFUL_SPACE_ID + '/environments/master/assets?access_token=' +
        CONTENTFUL_ACCESS_TOKEN +
        '&metadata.tags.sys.id[all]=videoToSendWhenNoMessages',
        timeout=10
    )

    all_videos = json.loads(response.content).get("items")

    random_video = all_videos[random.randint(0, len(all_videos) - 1)]
    video_link = str(random_video.get("fields").get("file").get("url")[2:])

    return video_link


async def get_options_color(color: str, chat_id: int):
    """
    Function get text for a mood color

    Parameters:
    color (str): color of mental state, can be:
        "green"
        "yellow"
        "orange"
        "red"
    chat_id (int): Telegram ID of user to send a message

    Returns:
    None
    """

    arr = []
    for item in texts.get("polls_answers"):
        if item.get("color") == color:
            arr.append(item)
    await get_texts_to_send_mood(rand_select_obj_texts(arr), chat_id)


async def get_texts_to_send_mood(arr: list, chat_id: int):
    """
    Function to create a support message from text format

    Parameters:
    arr (list): message "polls_answers" from texts.json
    chat_id (int): Telegram ID of user to send a message

    Returns:
    None
    """

    for item in arr.get("answers_arrays"):
        if (item[0] == '*' and arr.get("is_labelled") == 1):
            if item == '*gif*':
                await botClient.send_video(chat_id, await get_cat_gif())

            if item == '*support*':
                user = get_user_by_telegram_id(str(chat_id))

                print("\n")
                print("Пользователь, кому отправляем сообщение")
                print(user["_id"])

                message_to_send = get_message_to_send_to_user(user['_id'])

                print("\n")
                print("Сообщение для показа")
                print(message_to_send)

                if len(message_to_send) != 0:
                    await create_message_with_support(user, message_to_send[0])
                else:
                    await botClient.send_message(
                        chat_id,
                        (
                            "Извини, сообщения на сегодня закончились 😞 \n"
                            "Вот видео от меня, оно точно поможет:"
                        )
                    )
                    await botClient.send_video(chat_id, await get_video_when_no_messages())

            if item == '*waiting_day_feedback*':
                print("поставить вызов функции")
                # поставить вызов функции <- Что должно быть тут??!

            if item == "*wait_for_answer_to_form*":
                s = await rand_select_obj_texts(texts.get('invite_to_form'))
                user = get_user_by_telegram_id(str(chat_id))
                await botClient.send_message(
                    chat_id,
                    s.get('text') + '\n' + LINK_TO_FORM + str(user['form_id']),
                    disable_web_page_preview=True
                )
        else:
            s = await rand_select_obj_texts(texts.get(item))
            await botClient.send_message(chat_id, s.get('text'))
            time.sleep(1)


async def row_message(chat_id: int):
    """
    Function to show number of total mental rates

    Parameters:
    chat_id (int): Telegram ID of user to send a message

    Returns:
    None
    """

    await botClient.send_message(
        chat_id,
        (
            "Ты уже замерил свое настроение " + str(how_many_days_user_with_us(chat_id)) +
            " раз! Продолжай в том же духе 😎"
        )
    )


async def offer_to_chat_with_chatgpt(color: str, user_id: int):
    """
    Function to offer to use ChatGPT

    Parameters:
    color (int): color of mental rate, can be:
        "green"
        "yellow"
        "orange"
        "red"
    user_id (int): Telegram ID of user to send a message

    Returns:
    None
    """

    if color in ['red', 'orange']:
        await botClient.send_message(
            user_id,
            (
                "Как насчет поболтать со мной? Я могу поддержать диалог: "
                "умею распознавать проблемы и давать осмысленные ответы. Попробуем?"
            ),
            reply_markup=support_start_keyboard
        )


def need_send_weekly_rate_stata(
    timezone_offset: int,
    created_at: datetime,
    id_user: ObjectId,
    rate_date: datetime
) -> bool:
    """
    Function, that is used to check whether we should display weekly stata to a user
        after they rated their mood

    Parameters:
    timezone_offset (int): user's timezone offset
    created_at (datetime): date at which this particular user was created
    id_user (ObjectId): Telegram ID of user to send a message
    rate_date (datetime): date at which the currently handled rate message was sent

    Returns:
    bool
    """

    try:
        today_is_monday_or_sunday = today_is_the_day(Weekdays.SUNDAY, timezone_offset) or \
            today_is_the_day(Weekdays.MONDAY, timezone_offset)
        rate_date_is_sunday = utc_date_is_the_day(
            rate_date, Weekdays.SUNDAY, timezone_offset)
        return \
            rate_date_is_sunday and \
            today_is_monday_or_sunday and \
            n_days_since_date(3, created_at) and \
            any_ratings_in_previous_n_days(id_user, 6)
    except MessageError as e:
        print(f'need_send_weekly_rate_stata failed check, exception: {e}')
        return False


async def sunday_send_rate_stata(chat_id: int, rate_date: datetime):
    """
    A non-destructive modification of send_rate stata
        for the purposes of sending weekly stata after a user
        has rated their mood on a Sunday.
    Sends a message from a collection of specially manufactured texts and then
        sends mental state statistics for the past week.

    Parameters:
    chat_id (int): Telegram ID of user to send a message
    rate_date (datetime): date at which the currently handled rate message was sent

    Returns:
    None
    """

    mes = await rand_select_obj_texts(texts.get('mental_week_stata'))
    await botClient.send_message(chat_id, mes['text'])
    # as mentioned before, rate date is in UTC+00 timezone,
    # but send_rate_stata expects a function that takes a
    # pytz.BaseTzInfo instance as its single parameter
    await send_rate_stata(str(chat_id), 'week', lambda ptz_utc: rate_date)
